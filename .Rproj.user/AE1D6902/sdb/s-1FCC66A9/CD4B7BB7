{
    "collab_server" : "",
    "contents" : "# This is a simple Bolinger Band trend following strategy. The system calculates a central\n# moving average band from the daily close. The number of days is a variable. The entry point is\n# defined as the close price crossing a  number of standard deviations away from the central\n# moving average. THe position is closed when the close price crosses back below another number\n# of standard deviations from the central moving average. Negative number means the other way.\n# This code assumes that you have a directory with csv files of OHLC daily data for testing\n\nlibrary(quantstrat)       # Required package for strategy back testing\nttz<-Sys.getenv('TZ')     # Time zone to UTC, saving original time zone\nSys.setenv(TZ='UTC')\n\nstrat        <- \"BB1\"       # Give the stratgey a name variable\nportfolio.st <- \"BB1\"       # Portfolio name\naccount.st   <- \"BB1\"       # Account name\ncsvDir       <- \"C:/Users/RJK/Documents/SpiderOak Hive/Financial/commodities_data\" # Directory containing csv files\nmaPeriod     <- 200          # moving average period\nbbBreakout   <- 2           # multiple of SD for breakout \nbbClose      <- 0           # multiple of SD for close\n\n# This function sets the standard devation parameter to pass to the \n# Bolinger Band indicator function\n\ncloseSD_final <-function(user_SD){\n  if(user_SD == 0){\n    returnSD <- 1\n  } else{\n    returnSD <- abs(user_SD)\n  }\n  return(returnSD)\n}\n\n# The following two functions set, based on the bbClose variable, which band the close must\n# cross in order for the strategy to exit. If number os +ve it is on the same side of the \n# moving average as the initial move, 0 is the MA and -ve is on the other side of the MA.\n\nlongExitBand <- function(user_SD){\n  if(user_SD == 0){\n    longBand <- \"mavg.BBands_close\"\n  } else if(user_SD > 0){\n    longBand <- \"up.BBands_close\" \n  } else {\n    longBand <- \"dn.BBands_close\"\n  }\n  return(longBand)\n}\n\nshortExitBand <- function(user_SD){\n  if(user_SD == 0){\n    shortBand <- \"mavg.BBands_close\"\n  } else if(user_SD > 0){\n    shortBand <- \"dn.BBands_close\" \n  } else {\n    shortBand <- \"up.BBands_close\"\n  }\n}\n\ncurrency('USD')             # set USD as a base currency\n\n# Universe selection\nsymbol <- c(\"LSU\",\"RR\",\"CO\",\"NG\",\"OJ\")\n\n# if run previously\nrm.strat(portfolio.st)\ndelete.paramset(strat,\"STOP_OPT\")\n\n# set the instument as a future and get the data from the csv file\nfor (sym in symbol){\n     \n     future(sym, currency = \"USD\", multiplier = 1)\n}\ngetSymbols(Symbols = symbol, verbose = TRUE, warnings = TRUE, \n           src = 'csv', dir= csvDir, extension='csv', header = TRUE, \n           stingsAsFactors = FALSE)\nfor (sym in symbol){\n  no_dup <- to.daily(get(sym), indexAt='days',drop.time = TRUE) # this is required to remove duplicate data\n  assign(sym, no_dup)\n}\n\n# initialize the portfolio, account and orders. Starting equity $10K and assuming data post 1998.\n\ninitPortf(portfolio.st, symbols = symbol, initDate = \"2000-01-01\")\ninitAcct(account.st, portfolios = portfolio.st, initEq = 1000000, initDate = \"2000-01-01\")\ninitOrders(portfolio = portfolio.st, initDate = \"2000-01-01\")\n\n# define the strategy with a position limit to prevent multiple trades in a direction\nstrategy(strat, store = TRUE)\nfor (sym in symbol){\naddPosLimit(strat, sym, timestamp=\"2000-01-01\", maxpos=100, \n            longlevels = 1, minpos=-100, shortlevels = 1)\n}\n\n# Add the indicators - One bband for the breakout another for the stop\n\nadd.indicator(strat, name = \"BBands\", \n              arguments = list(HLC = quote(Cl(mktdata)), \n                               n = maPeriod, maType = 'SMA',sd = bbBreakout\n              ),\n              label = \"BBands_breakout\"\n)\n\nadd.indicator(strat, name = \"BBands\", \n              arguments = list(HLC = quote(Cl(mktdata)), \n                               n = maPeriod, maType = 'SMA',sd = closeSD_final(bbClose)\n              ),\n              label = \"BBands_close\"\n)\n\n# Add the signals -  Go long on a cross of the close greater than the breakout band and close on a cross \n# less than the close band. Signals reversed for a short.\n\nadd.signal(strat, name = \"sigCrossover\", \n           arguments = list(columns=c(quote(Cl(mktdata)),\"up.BBands_breakout\"),\n                            relationship = \"gt\"\n           ), \n           label = \"long_entry\"\n)\n\nadd.signal(strat, name = \"sigCrossover\", \n           arguments = list(columns=c(quote(Cl(mktdata)),longExitBand(bbClose)), \n                            relationship = \"lt\"\n           ), \n           label = \"long_exit\"\n)\n\nadd.signal(strat, name = \"sigCrossover\", \n           arguments = list(columns=c(quote(Cl(mktdata)),\"dn.BBands_breakout\"), \n                            relationship = \"lt\"\n           ), \n           label = \"short_entry\"\n)\n\nadd.signal(strat, name = \"sigCrossover\", \n           arguments = list(columns=c(quote(Cl(mktdata)),shortExitBand(bbClose)), \n                            relationship = \"gt\"\n           ), \n           label = \"short_exit\"\n)\n\n# Add the rules - what trades to make on the signals giving using osMaxPos to limit positions.\n\nadd.rule(strat, name = 'ruleSignal', \n         arguments = list(sigcol = \"long_entry\", \n                          sigval = TRUE, orderqty = 100, ordertype = 'market', \n                          orderside ='long', osFUN='osMaxPos', orderset = 'ocolong'\n         ), \n         type ='enter', label = \"LE\"\n)\n\nadd.rule(strat, name = 'ruleSignal', \n         arguments = list(sigcol = \"long_exit\", \n                          sigval = TRUE, orderqty = 'all', ordertype = 'market', \n                          orderside ='long', orderset = \"ocolong\"\n         ), \n         type ='exit', label = \"LX\"\n)\n\nadd.rule(strat, name = 'ruleSignal', \n         arguments = list(sigcol = \"short_entry\", \n                          sigval = TRUE, orderqty = -100, ordertype ='market', \n                          orderside = 'short', osFUN='osMaxPos', orderset = 'ocoshort'\n         ), \n         type ='enter', label = 'SE'\n)\n\nadd.rule(strat, name = 'ruleSignal', \n         arguments = list(sigcol = \"short_exit\", \n                          sigval = TRUE, orderqty = 'all', ordertype ='market', \n                          orderside ='short', orderset = 'ocoshort'\n         ), \n         type ='exit', label = \"SX\"\n)\n\nout <- applyStrategy(strategy=strat , portfolios=portfolio.st) # Attempt the strategy\nupdatePortf(Portfolio = portfolio.st)                          # Update the portfolio\nupdateAcct(name = account.st)\nupdateEndEq(account.st)\n\n# Plot the charts fo each symbol\nfor (sym in symbol){\n  chart.Posn(Portfolio = portfolio.st, Symbol = sym, TA=\"add_BBands(n=20,sd=2)\")          # Chart the position\n}\nstats <- tradeStats(portfolio.st)\n\neq1 <- getAccount(account.st)$summary$End\nrt1 <- Return.calculate(eq1,\"log\")\n\ngetSymbols(\"^GSPC\", from = '2000-01-01')\nchartSeries(GSPC, type=\"candlesticks\", theme = chartTheme(\"white\"))\nrt2 <- periodReturn(GSPC, period = \"daily\")\nreturns <- cbind(rt1,rt2)\ncolnames(returns) <- c(\"BB\",\"SP500\")\nchart.CumReturns(returns,colorset=c(2,4),legend.loc=\"topleft\",\n                 main=\"BBand to Benchmark Comparison\",ylab=\"cum return\",xlab=\"\",\n                 minor.ticks=FALSE)\nSys.setenv(TZ=ttz)                                             # Return to original time zone\n",
    "created" : 1486632790762.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3949893253",
    "id" : "CD4B7BB7",
    "lastKnownWriteTime" : 1486641970,
    "last_content_update" : 1486641970905,
    "path" : "~/R/bBandTrend/BBBreak_multi.R",
    "project_path" : "BBBreak_multi.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}