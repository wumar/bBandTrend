{
    "collab_server" : "",
    "contents" : "# This is a simple Bolinger Band trend following strategy. The system calculates a central\n# moving average band from the daily close. The number of days is a variable. The entry point is\n# defined as the close price crossing a  number of standard deviations away from the central\n# moving average. THe position is closed when the close price crosses back below another number\n# of standard deviations from the central moving average. Negative number means the other way.\n# Here we incorporate optimization via paramsets, using the bbBreakout variable first, the adding\n# the moving average.\n\nlibrary(quantstrat)       # Required package for strategy back testing\nlibrary(doParallel)       # For parrallel optimization\nlibrary(rgl)              # Library to load 3D trade graphs\nlibrary(reshape2)         # Library to load 3D trade graphs\nttz<-Sys.getenv('TZ')     # Time zone to UTC, saving original time zone\nSys.setenv(TZ='UTC')\n\ncsvDir       <- \"C:/Users/RJK/Documents/SpiderOak Hive/Financial/commodities_data\" # Directory containing csv files\nstrat        <- \"BB1\"       # Give the stratgey a name variable\nportfolio.st <- \"BB1\"       # Portfolio name\naccount.st   <- \"BB1\"       # Account name\nmaPeriod     <- seq(50, 200, by = 50)       # moving average period\nbbBreakout   <- seq(1, 4, by = 1)           # multiple of SD for breakout \nbbClose      <- -1                          # multiple of SD for close\n\n# This function sets the standard devation parameter to pass to the \n# Bolinger Band indicator function\n\ncloseSD_final <-function(user_SD){\n  if(user_SD == 0){\n    returnSD <- 1\n  } else{\n    returnSD <- abs(user_SD)\n  }\n  return(returnSD)\n}\n\n# The following two functions set, based on the bbClose variable, which band the close must\n# cross in order for the strategy to exit. If number os +ve it is on the same side of the \n# moving average as the initial move, 0 is the MA and -ve is on the other side of the MA.\n\nlongExitBand <- function(user_SD){\n  if(user_SD == 0){\n    longBand <- \"mavg.BBands_close\"\n  } else if(user_SD > 0){\n    longBand <- \"up.BBands_close\" \n  } else {\n    longBand <- \"dn.BBands_close\"\n  }\n  return(longBand)\n}\n\nshortExitBand <- function(user_SD){\n  if(user_SD == 0){\n    shortBand <- \"mavg.BBands_close\"\n  } else if(user_SD > 0){\n    shortBand <- \"dn.BBands_close\" \n  } else {\n    shortBand <- \"up.BBands_close\"\n  }\n}\n\ncurrency('USD')             # set USD as a base currency\n\n# Universe selection\nsymbol <- c(\"LSU\",\"RR\",\"CO\",\"NG\",\"OJ\")\n\n# if run previously, run this code\nrm.strat(portfolio.st)\ndelete.paramset(portfolio.st,\"BB_OPT\")\n\n# set the instument as a future and get the data from the csv file\nfor (sym in symbol){\n  \n  future(sym, currency = \"USD\", multiplier = 1)\n}\n\ngetSymbols(Symbols = symbol, verbose = TRUE, warnings = TRUE, \n           src = 'csv', dir= csvDir, extension='csv', header = TRUE, \n           stingsAsFactors = FALSE)\n\nfor (sym in symbol){\n  no_dup <- to.daily(get(sym), indexAt='days',drop.time = TRUE) # this is required to remove duplicate data\n  assign(sym, no_dup)\n}\n\n# initialize the portfolio, account and orders. Starting equity $10K and assuming data post 1998.\n\ninitPortf(portfolio.st, symbols = symbol, initDate = \"1995-01-01\")\ninitAcct(account.st, portfolios = portfolio.st, initEq = 10000, initDate = \"1995-01-01\")\ninitOrders(portfolio = portfolio.st, initDate = \"1995-01-01\")\n\n# define the strategy with a position limit to prevent multiple trades in a direction\nstrategy(strat, store = TRUE)\nfor (sym in symbol){\n  addPosLimit(strat, sym, timestamp=\"2000-01-01\", maxpos=100, \n              longlevels = 1, minpos=-100, shortlevels = 1)\n}\n\n# Add the indicators - One bband for the breakout another for the stop\n\nadd.indicator(strat, name = \"BBands\", \n              arguments = list(HLC = quote(Cl(mktdata)), \n                               n = maPeriod, maType = 'SMA',sd = bbBreakout\n                               ),\n              label = \"BBands_breakout\"\n              )\n\nadd.indicator(strat, name = \"BBands\", \n              arguments = list(HLC = quote(Cl(mktdata)), \n                               n = maPeriod, maType = 'SMA',sd = closeSD_final(bbClose)\n                               ),\n              label = \"BBands_close\"\n              )\n\n# Add the signals -  Go long on a cross of the close greater than the breakout band and close on a cross \n# less than the close band. Signals reversed for a short.\n\nadd.signal(strat, name = \"sigCrossover\", \n           arguments = list(columns=c(quote(Cl(mktdata)),\"up.BBands_breakout\"),\n                            relationship = \"gt\"\n                            ), \n           label = \"long_entry\"\n           )\n\nadd.signal(strat, name = \"sigCrossover\", \n           arguments = list(columns=c(quote(Cl(mktdata)),longExitBand(bbClose)), \n                            relationship = \"lt\"\n                            ), \n           label = \"long_exit\"\n           )\n\nadd.signal(strat, name = \"sigCrossover\", \n           arguments = list(columns=c(quote(Cl(mktdata)),\"dn.BBands_breakout\"), \n                            relationship = \"lt\"\n                            ), \n           label = \"short_entry\"\n           )\n\nadd.signal(strat, name = \"sigCrossover\", \n           arguments = list(columns=c(quote(Cl(mktdata)),shortExitBand(bbClose)), \n                            relationship = \"gt\"\n                            ), \n           label = \"short_exit\"\n           )\n\n# Add the rules - what trades to make on the signals giving using osMaxPos to limit positions.\n\nadd.rule(strat, name = 'ruleSignal', \n         arguments = list(sigcol = \"long_entry\", \n                          sigval = TRUE, orderqty = 100, ordertype = 'market', \n                          orderside ='long', osFUN='osMaxPos', orderset = 'ocolong'\n                          ), \n         type ='enter', label = \"LE\"\n         )\n\nadd.rule(strat, name = 'ruleSignal', \n         arguments = list(sigcol = \"long_exit\", \n                          sigval = TRUE, orderqty = 'all', ordertype = 'market', \n                          orderside ='long', orderset = \"ocolong\"\n                          ), \n         type ='exit', label = \"LX\"\n         )\n\nadd.rule(strat, name = 'ruleSignal', \n         arguments = list(sigcol = \"short_entry\", \n                          sigval = TRUE, orderqty = -100, ordertype ='market', \n                          orderside = 'short', osFUN='osMaxPos', orderset = 'ocoshort'\n                          ), \n         type ='enter', label = 'SE'\n         )\n\nadd.rule(strat, name = 'ruleSignal', \n         arguments = list(sigcol = \"short_exit\", \n                          sigval = TRUE, orderqty = 'all', ordertype ='market', \n                          orderside ='short', orderset = 'ocoshort'\n                          ), \n         type ='exit', label = \"SX\"\n         )\n\n#add paramset distributions\nadd.distribution(portfolio.st,\n                 paramset.label = \"BB_OPT\",\n                 component.type = \"indicator\",\n                 component.label = \"BBands_breakout\",\n                 variable = list( sd = bbBreakout ),\n                 label = \"bb_break\"\n)\n\nadd.distribution(portfolio.st,\n                 paramset.label = \"BB_OPT\",\n                 component.type = \"indicator\",\n                 component.label = \"BBands_breakout\",\n                 variable = list( n = maPeriod ),\n                 label = \"ma_b\"\n)\n\nadd.distribution(portfolio.st,\n                 paramset.label = \"BB_OPT\",\n                 component.type = \"indicator\",\n                 component.label = \"BBands_close\",\n                 variable = list( n = maPeriod ),\n                 label = \"ma_c\"\n)\n\nadd.distribution.constraint(portfolio.st,\n                            paramset.label = \"BB_OPT\",\n                            distribution.label.1 = \"ma_b\",\n                            distribution.label.2 = \"ma_c\",\n                            operator = \"==\",\n                            label = \"mabeqmac\")\n\nregisterDoParallel(cores=detectCores())\n\nout <- apply.paramset(strat, paramset.label = \"BB_OPT\",\n                      portfolio=portfolio.st, account = account.st, nsamples=0, verbose = TRUE)\n\nstats <- out$tradeStats\n\n# It is possible to subset the trade stats by symbol for multiple symbols using e.g.\n\nCOstats <- subset(stats, Symbol == \"CO\") \n\ntradeGraphs(stats = stats, \n            free.params=c(\"bb_break\",\"ma_b\"),\n            statistics = c(\"Net.Trading.PL\",\"Max.Drawdown\",\"Ann.Sharpe\"), \n            title = \"BB Scan\")\n\nSys.setenv(TZ=ttz)                                             # Return to original time zone\n",
    "created" : 1486630428328.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3278087501",
    "id" : "D486A561",
    "lastKnownWriteTime" : 1486674387,
    "last_content_update" : 1486674387515,
    "path" : "~/R/bBandTrend/BBBreakv2.R",
    "project_path" : "BBBreakv2.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}